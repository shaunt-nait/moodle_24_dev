# Matrices and vectors in STACK.

## Matrices ##

Note that in Maxima, matrix multiplication is the dot, e.g.
`A.B`.  The star `A*B` gives element-wise multiplication.

The paper
[Setting Linear Algebra Problems](http://web.maths.unsw.edu.au/~jds/Papers/linalg.pdf)
is rather interesting.

The following functions are part of Maxima, but are very useful for us.

    rowswap(m,i,j)
    addrow(m,i,j,k)

Where ` m[i]: m[i] + k * m[j]`.

    rowmul(m,i,k)

Where `m[i]: k * m[i]`.
And a function to compute reduced row echelon form

    rref(m)

## Assigning individual elements ##

To assign values to individual elements, use the simple syntax such as the following.

    m:matrix([1,1],[1,2])
    m[1,2]:3

### Showing working {#Showing_working}

It is quite common to want to show part of a matrix calculation "un-evaluated".  For example, the following is typical.

\[ \left[\begin{array}{cc} 1 & 2 \\ 4 & 5 \\ \end{array}\right] + \left[\begin{array}{cc} 1 & -1 \\ 1 & 2 \\ \end{array}\right] = \left[\begin{array}{cc} 1+1 & 2-1 \\ 4+1 & 5+2 \\  \end{array}\right] = \left[\begin{array}{cc} 2 & 1 \\ 5 & 7 \\ \end{array}\right] .\]

This is achieved, by having a question in which simplification is off, and we define the question variables as follows.

    A:matrix([1,2],[4,5]);
    B:matrix([1,-1],[1,2]);
    C:apply(matrix,zip_with(lambda([l1,l2],zip_with("+",l1,l2)),args(A),args(B)));
    D:ev(C,simp);

Notice the use of `zip_with` which is not a core Maxima function, but is defined by STACK.
The above equation is then generated by the CASText

\[ @A@+@B@=@C@=@D@.\]

A similar procedure is needed for showing working when multiplying matrices.   Here we need to loop over the matrices, but there must be a more elegant way to do this.

    A:ev(rand(matrix([5,5],[5,5]))+matrix([2,2],[2,2]),simp);
    B:ev(rand(matrix([5,5],[5,5]))+matrix([2,2],[2,2]),simp);
    BT:transpose(B);
    C:zeromatrix (first(matrix_size(A)), second(matrix_size(A)));
    S:for a:1 thru first(matrix_size(A)) do for b:1 thru second(matrix_size(A)) do C[ev(a,simp),ev(b,simp)]:apply("+",zip_with("*",A[ev(a,simp)],BT[ev(b,simp)]));
    D:ev(C,simp);

Notice we need to simplify the arguments before we take indices of expressions.  This is one problem with `simp:false`.

## Vectors ##

If you are trying to use the vector notation such as \(3i+4j\) you will probably want to redefine \(i\) to be an abstract symbol, not a complex number.
More information on this is given under [Numbers](Numbers.md).

## See also

[Maxima reference topics](index.md#reference).
