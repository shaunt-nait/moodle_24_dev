# Random objects #

One of the features of STACK is the ability to generate structured random objects.
To do this STACK provides a [Maxima](Maxima.md) function `rand()` which can be used in the question and answer variables.
Other related functions make use of this.

For the purposes of learning and teaching, we do not need an algorithm which is statistically perfect.
We are much more interested in simplicity, efficiency and reproducibility across platforms.
Hence, we adopt a linear recurrence method of generating pseudo-random numbers.

**Note** it is important not to use Maxima's own `random()` function.
STACK creates pseudo-random numbers from a definite seed.
This ensures that when a particular student returns they see the same version of the question.
Hence, STACK provides its own function `rand()`.

## rand() {#rand}

* `rand(n)` generates an integer between \(0\) and \(n-1\).
* `rand(n.0)` generates a floating point number between \(0\) and \(n\).  It is probably more useful to use something like a=float(rand(1000)/1000)
  to obtain an accurate number of decimal places.  An alterative is to use the [Maxima](Maxima.md) function `round()`
* `rand([a,b,...,z])` makes a random selection from a list.
* `rand(matrix(..))` applies rand to each element of the matrix.

It is probably much better **not** to use conditional statements when creating random objects.
For example, if you would like to create a random small prime number, try

    p : rand([2,3,5,7,11,13,17,19]);

This might not appear to be the neatest mathematical solution, but it is probably the most reliable.
Usually we need to combine `rand()` with some code to generate objects.
For example, if you want a matrix with integer elements in the range -5..5 you need something like

    A:matrix([5,5],[5,5])-rand(matrix([11,11],[11,11]));

### rand_with_step (lower,upper,step) ###

Returns a random number from the set {lower, lower+step, lower+2*step, ... , final}. The examples below explain behaviour the best.
Examples:

* `rand_with_step(-5,5,1)` returns a random number from the set \(\{-5,-4,-3,-2,-1,0,1,2,3,4,5\}\).
* `rand_with_step(-5,5,2)` returns a random number from the set \(\{-5,-3,-1,1,3,5\}\).
* `rand_with_step(-5,3,3)` returns a random number from the set \(\{-5,-2,1\}\).

### rand_with_prohib(lower,upper,list) ###

Returns a random integer from the set [lower,upper] such that it cannot be any value in list.
This list can include values which are also random variables, for example, generated by `rand_with_step`.
Examples:

* `rand_with_prohib(-5,5,[0])` returns a random number from the set \(\{-5,-4,-3,-2,-1,1,2,3,4,5\}\).
* `rand_with_prohib(-5,5,[-1,0,1,sqrt(pi)])` returns a random number from the set \(\{-5,-4,-3,-2,2,3,4,5\}\).
* `rand_with_prohib(-5,3,[-5/2,a])` returns a random number from the set \(\{-5,-4,-3,-2,-1,0,1,2,3\}\backslash\{a\}\).

This can be used with matrices, to generate a matrix with non-zero entries for example.  The unnamed function in this example ignores its arguments.

    matrixmap(lambda([ex],rand_with_prohib(-5,5,[0])),zeromatrix(5,5));

## Generating random polynomials

Here is an example which generates a random polynomial, of degree 5, with coefficients between 0 and 6.

    apply("+",makelist(rand(7)*x^(k-1),k,6));

## Generating random expressions which need to be "gathered and sorted".

It is relatively common to want to be able to generate random expressions which need to be "gathered and sorted".  For example in \(2y-y+3y+1\) we need to collect together the \(y\) terms.

    simp:false;
    p:apply("+",makelist(ev(rand_with_prohib(-5,5,[0])*y^rand(2),simp), ev(rand(6)+2,simp)));
    p:unary_minus_sort(p);

Now, the output from the first expression will be a random expression in constants and \(y\) variables.   The second line tidies up the unary minus.  For more details of this, see [simplification](Simplification.md).

    4*y+5*y+(-2*y)
    4*y+5*y-2*y

## See also

[Maxima reference topics](index.md#reference).
