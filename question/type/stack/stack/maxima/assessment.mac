/*  Author Chris Sangwin
    University of Birmingham
    Copyright (C) 2012 Chris Sangwin

    This program is free software: you can redistribute it or modify
    it under the terms of the GNU General Public License version two.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>. */


/****************************************************************/
/*  An assessment package for Maxima                            */
/*                                                              */
/*  Chris Sangwin, <chris@sangwin.com>                          */
/*  V0.5 January 2012                                           */
/*                                                              */
/****************************************************************/

MAXIMA_VERSION:map(parse_string, tokens(?\*autoconf\-version\*, 'digitcharp))$
MAXIMA_VERSION_NUM:float(MAXIMA_VERSION[2]+MAXIMA_VERSION[3]/10)$

/* Note how Maxima has changes this.... */
DIV_OP:"//"$
if MAXIMA_VERSION_NUM>=15.0 then DIV_OP:"/"$ 

/* ********************************** */
/* Load contributed packages          */
/* ********************************** */

if not(?functionp('poly_reduced_grobner)) then load("grobner");

/* ********************************** */
/* Parts of expressions               */
/* ********************************** */

/* op(ex) is unsafe on atoms: this is a fix. */
/* This function always returns a string     */
safe_op(ex) := block(
  if atom(ex) then return(""),
  if stringp(op(ex)) then return(op(ex)) else return(string(op(ex)))
)$

/* This function takes an expression ex and returns a list of coefficients of v */
coeff_list(ex,v):= block([deg,kloop,cl],
   cl:[],
   ex:ev(expand(ex),simp),
   deg:hipow(ex,v),
   ev(for kloop:0 thru deg do
     cl:append(cl,[coeff(ex,v,kloop)]),simp),
   cl
)$

/* This function takes an expression ex and returns a list of nonzero coefficients of v */
coeff_list_nz(ex,v):= block([deg,kloop,cl],
   cl:[],
   ex:ev(expand(ex),simp),
   deg:hipow(ex,v),
   ev(for kloop:0 thru deg do
     if coeff(ex,v,kloop)#0 then cl:append(cl,[[kloop,coeff(ex,v,kloop)]]),simp),
   cl
)$

/* Return the set of operations which occur in the expression */
/* Note, this function varies depending on the value of simp! */
/* E.g. x+x-> 2*x, so is this a product of sum?               */
get_ops(ex):= setify(flatten(get_ops_helper(ex)))$
get_ops_helper(ex):=if atom(ex) then [] else append([op(ex)],maplist(get_ops_helper,args(ex)))$

/* ********************************** */
/* General list and utility functions */
/* ********************************** */

/* True if and only if ex is in the list l */
element_listp(ex,l):= any_listp(lambda([ex2],is(ex2=ex)),l)$

/* all_listp(p,l) true if all elements of l satisfy p */
all_listp(p,l):= if listp(l) then ret:apply("and",maplist(p,l)) else ret:"fail"$

/* any_listp(p,l) true if all elements of l satisfy p */
any_listp(p,l):= if listp(l) then ret:apply("or",maplist(p,l)) else ret:"fail"$

/* This function applies the binary function zf to two lists a and b returning a list
[ zf(a[1],b[1]), zf(a[2],b[2]), ... ] zip_with quietly gives up when one of the list runs out of elements.  */
zip_with(zf, a, b) := block(
  if not(listp(a)) then return(false),
  if not(listp(b)) then return(false),
  if emptyp(a) then return([]),
  if emptyp(b) then return([]),
  cons(zf(first(a), first(b)),  zip_with(zf, rest(a), rest(b)))
)$

/* This function makes a substitution of all variables for their lower case equivalents.
   Useful when wanting to do a specific case sensitivity 
   check, e.g. that X^2=1 is x^2=1, without using subst_equiv. 
 
   Note that exdowncase(X-x)=0, of course! 
*/
exdowncase(ex):=block([lv],
  lv:listofvars(ex),
  lv:map(lambda([v],v=parse_string(sdowncase(string(v)))),lv),
  return(subst(lv,ex)))$


/* ********************************** */
/* Type predicates                    */
/* ********************************** */

/* Determines if we are using an equation */
equationp(ex) := block(
   if atom(ex) then return(false),
   if "="= op(ex) then return(true),
   return(false)
)$

/* Determines if we are using a function */
functionp(ex) := block(
   if atom(ex) then return(false),
   if ":="= op(ex) then return(true),
   return(false)
)$

/* Determines if we are using an inequality */
inequalityp(ex) := block(
   if atom(ex) then return(false),
   if ">"= op(ex) or "<"= op(ex) or ">="= op(ex) or "<="= op(ex) then return(true),
   if "and"= op(ex) or "or"= op(ex) or "not" then return(true),
   return(false)
)$

expressionp(ex) := block(
 if matrixp(ex) or listp(ex) or equationp(ex) or inequalityp(ex) or setp(ex) or functionp(ex) then
    return (false),
 return(true)
);

/* Checks that an expression is a polynomial */
polynomialpsimp(e):= polynomialp(e, listofvars(e))$

/* ********************************** */
/* Numerical operations               */
/* ********************************** */

/* numberp() does not "work" when simp:false, since unary minus is an unevaluated function... */
simp_numberp(ex) := block(
  if numberp(ex) then return(true),
  if atom(ex) then return(false),
  if op(ex)="-" and numberp(first(args(ex))) then return(true),
  false
)$

/* Do we have a real number?*/
/* Code taken from Stack_Test */
real_numberp(ex):=
    block([keepfloat,trigexpand,logexpand],
    trigexpand:true,              /* see pg 80 */
    logexpand:super,
    keepfloat:true,               /* see pg 23 */
    ex:errcatch(ev(fullratsimp(ex),simp)),
    if ex=[] then return(false),
    ex:ev(float(ex[1]),simp),
    if listofvars(ex)#[] then return(false),
    if floatnump(ex) then return(true) else return(false)
)$    
    
/* Write the number x in n decimal places */
decimalplaces(x,n) := ev(float(round(10^n*float(x))/(10^n)),simp)$

/* Write numbers in significant figures */
/* Matti Pauna, Sun, 23 Oct 2011        */
significantfigures(x,n) := block([fpprec:128,fpprintprec,simp:true,ex,ex2],
  if x = 0 then return(0),
  if x = 0.0 then return(0.0),
  sign_of_x : signum(x),
  x : abs(x),
  ex:floor(float(log(x)/log(10))),
  ex2:round(float(x/10^(ex-n+1))),
  ex2:float(ex2*10^(ex-n+1)),
  if floor(ex2)=ratsimp(ex2) then ex2:ratsimp(ex2),
  return(sign_of_x*ex2)
);


scientific_notation(x) := block([simp:false,fpprintprec,ex,ex2,ex3],
  if real_numberp(x) and ev(x>0,simp) then (
      ex:ev(floor(float(log(x)/log(10))),simp),
      ex2:ev(float(x/10^ex),simp),
      ex3:ex2*10^ex,
      return(ex3)
  ) else return (x)
);

/* commonfaclist(l) returns the gcd of a list of numbers */
commonfaclist(l) := block([i,a,ret],
 if listp(l) then
  ret:( a:l[1],
        if length(l)>1 then
            ev(for i:2 thru length(l) do (a:ev(gcd(a,l[i]),simp)),simp),
        return(a))
  else ret:"fail",
 return(ret) )$

/* Returns a list of factors of ex without multiplicities */
factorlist(ex) := block([simp:false,ret:"",ex2],
  ex:ev(factor(ex),simp),
  if atom(ex) then return([ex]),
  if op(ex)#"*" then
     ret:[ex]
  else
     ret:args(ex),
  /* now strip off powers */
  ret:maplist(lambda([ex2],if atom(ex2) then ex2 else if op(ex2)="^" then part(ex2,1) else ex2),ret),
  return(ret)
)$

/* Is the fraction in its lowest terms? */
lowesttermsp(ex) := block([simp:false,ex1,ex2,ex3],
  if atom(ex) then return(true),
  if op(ex)#DIV_OP then return(true),
  if gcd(num(ex),denom(ex))=1 then return(true) else return(false)
)$

/* Create a list with all parts for which numberp(ex)=true, or which appear to be rational numbers */
list_expression_numbers(ex) := block([ex2],
  if atom(ex) then (if numberp(ex) then return([ex]) else return([]))
  else (
  if op(ex)=DIV_OP and simp_numberp(num(ex)) and simp_numberp(denom(ex)) then return([ex]),
  ex2:args(ex),
  flatten(maplist(list_expression_numbers,ex2)))
)$

all_lowest_termsex(ex):= block([simp:false,ex2],
  ex2:list_expression_numbers(ex),
  all_listp(lowesttermsp,ex2)
)$

/* anyfloats(l) returns true if any of the list are floats */
anyfloat(l) := block([ret:false],
 if listp(l)=false then ret:"fail",
 ev(l:map('floatnump,l),simp),
 ev(for i:1 thru length(l) do (ret:ret or l[i]),simp),
 return(ret) )$

/* Decides if any floats are in the expression. */
anyfloatex(ex) := block([partswitch,ret,kloop],
  ret:false,
  ex:ev(ex,simp),
  if floatnump(ex) then return(true),
  if atom(ex)      then return(false),
  partswitch:true,
  ev(for kloop:1 while part(ex,kloop)#end do
         ret:ret or anyfloatex(part(ex,kloop)),simp),
  return(ret)
)$

/* compare with*/
/* coefl:map('first,rest(coeffs(SA,x))) */

/* ********************************** */
/* Inequalities                       */
/* ********************************** */

infix("=>");
"=>"(a,b):=a>=b;
infix("=<");
"=<"(a,b):=a<=b;


/* Reduces an inequality to either ? > 0 or ? >=0, which is monic in its variable. */
ineqprepare(ex) := block([op2,ex2],
    if atom(ex) then return(ex),
    if op(ex)="="  then return(make_monic(ev(part(ex,1) - part(ex,2),simp,trigreduce)) = 0),
    if op(ex)=">"  then return(make_monic(ev(part(ex,1) - part(ex,2),simp,trigreduce)) > 0),
    if op(ex)=">=" then return(make_monic(ev(part(ex,1) - part(ex,2),simp,trigreduce)) >= 0),
    if op(ex)="<"  then return(make_monic(ev(part(ex,2) - part(ex,1),simp,trigreduce)) > 0),
    if op(ex)="<=" then return(make_monic(ev(part(ex,2) - part(ex,1),simp,trigreduce)) >= 0),
    ex2:args(ex),
    ex2:map(ineqprepare,ex2),
    return(apply(op(ex),ex2))
)$

/* Turn an single variable polynomial expression into a +1/-1 monic polynomial */
make_monic(ex):=block(
    if atom(ex) then return(ex),
    if not(polynomialpsimp(ex)) then return(ex),
    if length(listofvars(ex))>1 then return(ex),
    ex:expand(ex),
    ev(expand(ex/abs(coeff(ex,first(listofvars(ex)),degree(ex,first(listofvars(ex)))))),simp)
)$

/* Writes an expression in a cannonical form */
ineqorder(ex) := ineqorder_f(ev(ineqprepare(ex),simp))$

/* This function prepares inequalities, removes duplicates (e.g. x>1 and 1<x end up the same. Finally it orders the result. */
ineqorder_f(ex) := block(
    if atom(ex) then return(ex),
    if op(ex)="and" then return(apply("and",sort(listify(setify((map(ineqorder_f,args(ex)))))))),
    if op(ex)="or" then return(apply("or",sort(listify(setify((map(ineqorder_f,args(ex)))))))),
    if op(ex)="not" then return(apply("not",sort(listify(setify((map(ineqorder_f,args(ex)))))))),
    return(ex)
)$

/* ********************************** */
/* Equivalence                        */
/* ********************************** */

/* A general all purpose function on **expressions**.
   Takes two objects and returns true if they are equal, and false otherwise
   This is a "bash as hard as possible" function

   26/9/12.  Avoid fullratsimp after exponentialize.  This results in a non-terminating process.
*/
algebraic_equivalence(SA,SB) :=
    block([keepfloat,trigexpand,logexpand,ex,vi],
    trigexpand:true,              /* see pg 80 */
    logexpand:super,
    keepfloat:true,               /* see pg 23 */
    ex:errcatch(ev(fullratsimp(SA-SB),simp)),
    if ex=[] then return(false),
    ex:ex[1],
    if floatnump(ex) then return(false),
    ex:num(ex),  /* after a fullratsimp, we have a ratio.  We should only need to consider the top */
    ex:trigsimp(ex),
    ex:rectform(ex),
    ex:exponentialize(ex),
    /* ex:trigreduce(ex), CJS, removed 21/1/2010.  This was breaking ATSingleFrac!  Don't know why. */
    if ratsimp(ex)=0 then return(true),
    ex:radcan(ex),
    ex:factcomb(ex),
    if ratsimp(ex)=0 then return(true),
    for vi:1 while ex#sqrtdenest(ex) do ex:sqrtdenest(ex),
    if ratsimp(ex)=0 then return(true) else return(false)
    )$

/* This function takes two expressions.
   It establishes if there exists a substitution of the variables of ex2 into ex1 which renders
   ex1 algebraically equivalent to ex2.
   If such a substitution exists the function returns it in a form so that

   ex2 = ev(ex1, subst_equiv(ex1,ex2))

   If no such permutation exists it returns the empty list [].
   If it could not establish this, because there are too many combinations to reasonably consider,
   then the function returns false.
*/
subst_equiv(ex1,ex2):=block([lv1,lv2,lvi,lvp,lvs,lve,il,perm_size,simp],
 simp:true,
 perm_size:4, /* This algorithm is order factorial(perm_size) and so this needs to be small. */
 lv1:listofvars(ex1),
 lv2:listofvars(ex2),
 if length(lv1)#length(lv2) then return([]),
 /* If the lists are too long, try a weaker condition */
 /* We assume the variables which occur in both are correctly assigned. */
 /* Can we find a permutation of those left in each? */
 if length(lv1)>perm_size then (
   lv1:setify(lv1),
   lv2:setify(lv2),
   lvi:intersection(lv1,lv2),
   lv1:listify(setdifference(lv1,lvi)),
   lv2:listify(setdifference(lv2,lvi))
  ),
 if length(lv1)>perm_size then return(false),
 /*                                  */
 lvp:listify(permutations(lv2)),
 /* Create a list of subsitutions */
 lvs:map(lambda([ex],zip_with("=",lv1,ex)),lvp),
 /* Create list of expressions with which to compare ex1 */
 lve:map(lambda([ex],ev(ex1,ex)),lvs),
 lve:map(lambda([ex],ATAlgEquivfun(ex,ex2)),lve),
 lve:map(second,lve),
 lve:map(lambda([ex],equal(ex,true)),lve),
 if apply("or",lve) then (il:sublist_indices(lve,identity),lvs[il[1]]) else []
)$

/* ********************************** */
/* Noun arithmetic                    */
/* ********************************** */

/* ** Noun forms of the arithmetic functions ** */

/* These function define arithmetic functions which do
   not perform their actual mathematical functions. That is to say
   noun forms of the standard arithmetic functions. This is to
   give much finer control over the simplification of very elementary
   expressions.
   
   Chris Sangwin 21 Oct 2005.
   Chris Sangwin 7 Nov 2009, with help from JHD.
*/

/* Create noun forms of the functions of +, -, *, / and ^ 
   as follows.
   + noun+ 
   - noun- 
   * noun* 
   / noun/
   ^ noun^
*/

/* For each of these we do the following.
   (1) They are defined as infix and nary operators in Maxima
       with the binding precedences of their namesakes.
   (2) The tex() function is modified to display them exactly as
       their namesakes.  This should work with a *mix* of noun and
       active operators
   (3) verb_arith(expr) which will replace noun versions with their
       active counterparts.
   (4) noun_arith(expr) which will replace arithmetic operators with their 
       noun counterparts.
*/

/* (1) */
nary("noun+",100);
prefix("noun-",100);
nary("noun*",120);
infix("noun/",122,123);
infix("noun^",140,139);
prefix("UNARY_RECIP",100);

/* (2) */
load("noun_arith.lisp"); 

/* (3) */

declare("noun+",commutative);
declare("noun+",lassociative);
declare("noun+",rassociative);

declare("noun*",commutative);
declare("noun*",lassociative);
declare("noun*",rassociative);

/* (4) */
verb_arith(ex) := block(
 ex:subst("+","noun+",ex), 
 ex:subst("*","noun*",ex), 
 ex:subst("-","noun-",ex), 
 ex:subst(DIV_OP,"noun/",ex), 
 ex:subst("^","noun^",ex), 
 define(UNARY_RECIP a, a^(-1)), 
 ex:ev(ex,UNARY_MINUS=-1),
 remfunction("noun+","noun*","noun/","noun^","noun-"),ex)$

/* (5) */
noun_arith(ex) := block(
 ex:subst("noun+","+",ex), 
 ex:subst("noun*","*",ex), 
 ex:subst(lambda([ex],UNARY_MINUS noun* ex),"-",ex), /* Unary minus really communtes with multiplication*/
 ex:subst(lambda([ex1,ex2], ex1 noun* (UNARY_RECIP ex2)),DIV_OP,ex),  /* Turn 1/x into x^(-1), in a special form */
 ex:subst("noun^","^",ex), 
 ev(ex))$

/* (6) Assumes we are working in the context of noun operators.*/
gather_reduce(ex) := block(
 ex:subst("+","noun+",ex), 
 ex:subst("*","noun*",ex), 
 ex:subst("-","noun-",ex), 
 ex:ev(ex,simp),
 ex:subst("noun+","+",ex), 
 ex:subst("noun*","*",ex), 
 ex:subst("noun-","-",ex), 
 ex)$

/*  (7)  */
/* Returns true iff ex1 and ex2 are equal up to commutativity and associativity */
equals_commute_associate(ex1,ex2) := block([oldsimp,ex1n,ex2n,ret],
  oldsimp:simp,
  simp:false,
  ex1n:noun_arith(ex1),
  ex2n:noun_arith(ex2),
  simp:true,
  if ex1n=ex2n then ret:true else ret:false,
  simp:oldsimp,
  ret)$

/* An answer test in the context of commutative+associative addition and multiplication.*/
ATEqualComAss(sa,sb) := 
    block([Validity, RawMark,FeedBack,AnswerNote,ret,SAA,SBB],
    Validity:true, RawMark:true, FeedBack:"", AnswerNote:"",
    SAA:errcatch(ev(sa,simp,fullratsimp,nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then return([false,false,StackAddNote("","ATEqualComAss_STACKERROR_SAns"),""]),
    SBB:errcatch(ev(sb,simp,fullratsimp,nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then return([false,false,StackAddNote("","ATEqualComAss_STACKERROR_TAns"),""]),
    /* We need to check things are of the same type */
    ret:ATSameTypefun(sa,sb),
    if ret[2]=false then    
        (ret[3]:StackAddNote("ATEqualComAss: ",StackTrimNote(ret[3])), return([false,ret[2],ret[3],ret[4]]) ),
    ret:block([simp:true,ret],ATAlgEquivfun(sa,sb)),
    if ret[2]=false then    
        (ret[3]:StackAddNote("ATEqualComAss: (AlgEquiv:false)",StackTrimNote(ret[3])), return([false,ret[2],ret[3],""])),
    /* Now actually apply this test */
    if equals_commute_associate(sa,sb) then 
        (RawMark:true, AnswerNote:"")
    else
        (RawMark:false, AnswerNote:StackAddNote("","ATEqualComAss: (AlgEquiv:true)")),
    return([Validity,RawMark,AnswerNote,FeedBack])
    )$


/* ********************************** */
/* Algebraic form                     */
/* ********************************** */

/* expandp(p) is true if p equals its expanded form */
expandp(p):= block([simp:true], if p=expand(p) then true else false)$

/* factorp(p) is true if p equals its factored form */
factorp(p) := block([a],
  if ev(p=factor(p),simp) then return(true),
  if atom(p) then return(false),
  /* Note, in Maxima factor((1-x)) = -(x-1), so we need to fix this, for learning and teaching! */
  if ev(-1*factor(p) = expand(-1*p),simp) then return(true),
  if op(p)="^" and atom(part(p,1)) then return(true),
  if op(p)="^" and factorp(part(p,1)) then return(true),
  if op(p)="*" then return(all_listp(factorp,args(p))),
  return(false) )$

/*  Write the polynomial in completed square form */
comp_square(ex,var) := block([vc],
   if not(atom(var)) or numberp(var) then (print("comp_square: var should be an atom but not a number.  "),return(ex)),
   ex:ratsimp(expand(ex)),
   if not(polynomialp(ex,[var])) then (print("comp_square: ex should be a polynomial in var.  "),return(ex)),
   if hipow(ex,var)#2 then (print("comp_square: ex should be a quadratic.  "),return(ex)),
   delta:(coeff(ex,var,1)^2-4*coeff(ex,var,2)*coeff(ex,var,0))/(4*coeff(ex,var,2)^2),
   vc:coeff(ex,var,1)/(2*coeff(ex,var,2)),
   return(coeff(ex,var,2)*((var+vc)^2-delta))
)$


/*********************/
/* Matrix operations */
/*********************/

/*
  Description : forme echelonne par lignes d'une matrice rectangulaire
    (a  coefficients dans un corps commutatif).
  Taken from http://www.math.utexas.edu/pipermail/maxima/2007/008246.html
*/

request_rational_matrix(m, pos, fn) :=
  if every('identity, map(lambda([s], every('ratnump,s)), args(m))) then true else
    print("Some entries in the matrix are not rational numbers. The result might be wrong.")$

rowswap(m,i,j) := block([n, p, r],
  require_matrix(m, "first", "rowswap"),
  require_integer(i, "second", "rowswap"),
  require_integer(j, "third", "rowswap"),
  n : length(m),
  if (i < 1) or (i > n) or (j < 1) or (j > n)
     then error("Array index out of bounds"),
  p : copymatrix(m),
  r : p[i],
  p[i] : p[j],
  p[j] : r,
  p)$

addrow(m,i,j,k) := block([n,p],
  require_matrix(m, "first", "addrow"),
  require_integer(i, "second", "addrow"),
  require_integer(j, "third", "addrow"),
  require_rational(k, "fourth", "addrow"),
  n : length(m),
  if (i < 1) or (i > n) or (j < 1) or (j > n)
      then error("Array index out of bounds"),
  p : copymatrix(m),
  p [i] : p[i] + k * p[j],
  p)$

rowmul(m,i,k) := block([n,p],
  require_matrix(m, "first", "addrow"),
  require_integer(i, "second", "addrow"),
  require_rational(k, "fourth", "addrow"),
  n : length(m),
  if (i < 1) or (i > n) then error("Array index out of bounds"),
  p : copymatrix(m),
  p [i] : k * p[i],
  p)$


rref(m):= block([p,nr,nc,i,j,k,pivot,pivot_row,debug],
  debug : 0,
  request_rational_matrix(m," ","rref"),
  nc: length(first(m)),
  nr: length(m),
  if nc = 0 or nr = 0 then
    error ("The argument to 'rref' must be a matrix with one or more rows and columns"),
  p:copymatrix(m),
  ci : 1, cj : 1,
  while (ci<=nr) and (cj<=nc) do
  (
    if (debug = 1) then (
	    disp(p),
	    print("curseur en ligne ",ci," et colonne ",cj)),
    pivot_row : 0, pivot : 0,
    for k : ci thru nr do (
       if ( abs(p[k,cj]) > pivot ) then (
         pivot_row : k,
         pivot : abs(p[k,cj]))),
         if (debug = 1) then
	   print("colonne ",cj," : pivot trouve ligne ", pivot_row,", valeur : ",pivot),
    if (pivot = 0) then (cj : cj +1)
    else (
      p : rowswap(p,ci,pivot_row),
	if (debug = 1) then      print (".. Echange : ",p),
      p : rowmul(p,ci,1/p[ci,cj]),
	if (debug = 1) then     print (".. Normalisation : ",p),
      for k : 1 thru nr do (
         if not (k=ci) then (p : addrow (p,k,ci,-p[k,cj]))),
      ci : ci+1, cj : cj+1)),
  p
)$

/* ********************************** */
/* Analysis tests                     */
/* ********************************** */

/* This determines if an expression is continuous
   ex the expression,
   v  the variable,
   xp the point at which to evaluate. */
continuousp(ex,v,xp) := block([lp,lm],
 lp: ev(limit(ex,v,xp,minus),simp),
 lm: ev(limit(ex,v,xp,plus),simp),
 /* print(lp), print(lm), */
 if  lp # und
  and lm # und
  and lp # ind
  and lm # ind
  and lp # inf
  and lm # inf
  and lp # minf
  and lm # minf
  and lp = lm
 then true else false
 )$


/* This determines if an expression is differentiable
   ex the expression,
   v  the variable,
   xp the point at which to evaluate,
   n  the number of times it is differentiated (optional).
*/
diffp(ex,[args]) := block([v,xp,n],
 v:args[1],
 xp:args[2],
 n:1,
 if length(args)=3 then n:args[3],
 return(continuousp(diff(ex,v,n),v,xp))
)$

/* ********************************** */
/* Buggy rules                        */
/* ********************************** */


/* (a+b)^n -> a^n+b^n */
buggy_pow(ex) := block([ex_ex],
  if atom(ex) then return(ex),
  if op(ex)="/" and atom(part(ex,2))#true and op(part(ex,2))="+" then return(map(lambda([ex2],part(ex,1)/ex2),part(ex,2))),
  if atom(part(ex,1)) or op(part(ex,1))#"+" then return(map(buggy_pow,ex)),
  if op(ex)="^" then return(map(lambda([ex2],ex2^buggy_pow(part(ex,2))),map(buggy_pow,part(ex,1)))),
  if op(ex)=sqrt then return(map(sqrt,map(buggy_pow,part(ex,1))))
)$

/* Naive adding of fractions! But see Farey sequences. */
mediant(ex1,ex2) := (num(ex1)+num(ex2))/(denom(ex1)+denom(ex2));


/* ********************************** */
/* Answer tests                       */
/* ********************************** */

AnswerTests : [AlgEquiv, EqualComAss, CasEqual, SameType, SubstEquiv, SysEquiv, Expanded, FacForm, SingleFrac, PartFrac, CompSquare, GT, GTE, NumAbsolute, NumRelative, NumSigFigs, LowestTerms, Diff, Int, String, StringSloppy, RegExp]$ 

